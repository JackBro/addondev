http://blog.asial.co.jp/414
http://www13.plala.or.jp/observe/index.html#gef
http://www.ibm.com/developerworks/jp/opensource/library/os-eclipse-gef11/
http://webcache.googleusercontent.com/search?q=cache:PmKPos0WkSUJ:d.hatena.ne.jp/chaosophy/20090706/1246949007+GEF+eclipse&cd=53&hl=ja&ct=clnk&gl=jp&lr=lang_ja&client=firefox-a
http://webcache.googleusercontent.com/search?q=cache:ZWdVcvknwg0J:d.hatena.ne.jp/chaosophy/20090709/1247104059+GEF%E3%81%AE%E3%82%A4%E3%83%99%E3%83%B3%E3%83%88%E3%83%8F%E3%83%B3%E3%83%89%E3%83%A9+%E3%81%9D%E3%81%AE1&cd=2&hl=ja&ct=clnk&gl=jp&client=firefox-a

		var res="";
		var lobj = gBrowser.selectedBrowser;
		var pval = [];
		var fval = [];
    for(var key in lobj)
		{
			try{
					//Application.console.log("gBrowser.mCurrentBrowser key:"+ key + " = " + typeof(gBrowser.mCurrentBrowser[key]));
					if(typeof(lobj[key]) == "function"){
						var func = lobj[key]+"";
						func = func.replace(key, '');
						var argsindex = func.indexOf(")");
						func = func.substring(0, argsindex+1);
						//res += "\t" + key + ":" + func + "{}," + "\n";
						fval.push("\t" + key + ":" + func + "{}," + "\n");
					}else{
						//res += "\t" + key + ":" + lobj[key] + "," + "\n";
						pval.push("\t" + key + ":" + lobj[key] + "," + "\n");
					}
			}catch(exc){
				//res += "name = " + name +" ERROR" + "\n"; 
			}
		}
		pval.sort();
		fval.sort();
		for(var k in pval){
			res+=pval[k];
		}
		for(var k in fval){
			res+=fval[k];
		}
		Application.console.log("res = "+ res);

http://mpc-hc.sourceforge.net/

http://monoist.atmarkit.co.jp/fembedded/articles/filesys/02/filesys_02a.html
http://sourceforge.net/projects/wakasi-eclipse/
http://jsdoc.sourceforge.net/

convertChromeURL chromeurl = jar:file:///D:/program/firefox36/chrome/browser.jar!/content/browser/browser.xul

http://wasabili.blog4.fc2.com/
http://mypace75.blog92.fc2.com/

http://kwappa.txt-nifty.com/blog/2009/04/post-b816.html
http://d.hatena.ne.jp/griefworker/20090612

http://aqubiblog.blogspot.com/2009/06/orgeclipseuicommands.html
http://subtech.g.hatena.ne.jp/cho45/comment?date=20071225
http://wasabili.blog4.fc2.com/page-2.html

resource stacklink_modules modules/
		Components.utils.import("resource://stacklink_modules/test.js");
		TestObj.msg("onClickStatusbarIcon");
//test.js
var EXPORTED_SYMBOLS = ["TestObj"];

var Application = Components.classes["@mozilla.org/fuel/application;1"].getService(Components.interfaces.fuelIApplication);

var TestObj=
{
	msg:function(text)
	{
		var mtext = text;
		Application.console.log("TestObj = " + mtext);
	}
}

# Please give the version number for Firebug and Firefox when discussing issues.
# Firebug 1.3 works with Firefox 3.0 and Firefox 2.0
# Firebug 1.4 works with Firefox 3.0 and Firefox 3.5
# Firebug 1.5 works with Firefox 3.5 and Firefox 3.6 
# Firebug 1.6 will work with Firefox 3.6 and Firefox 3.7 //bindings.xml debug
# Firebug Lite works with IE, Safari, and Opera

/chrome/content/ff-overlay.xul
/chrome/content/ff-overlay.js
/chrome/content/options.xul
/chrome/locale/en-US/overlay.dtd
/chrome/skin/overlay.css
/defaults/preferences/prefs.js
/chrome.manifest
/install.rdf

http://answertaker.com/security/antispyware/superantispyware.html
https://addons.mozilla.org/ja/developers/tools/builder
http://www.eclipse.org/forums/index.php?t=msg&goto=369125&
http://blog.8maki.jp/2009/10/nixysa-npapi-gluecode-genereator.html
https://addons.mozilla.org/ja/firefox/addon/6622

bp.type &= ~BP_TRACE;

http://d.hatena.ne.jp/taichitaichi/searchdiary?of=15&word=*[eclipse]

http://www.eclipse.org/tptp/index.php
http://www.computerworld.jp/topics/osst/145669.html

eclipse\dropins\findbugs\eclipse\plugins\edu.umd.cs.findbugs.plugin.eclipse_1.3.9.20090821
http://findbugs.sourceforge.net/

http://www.hellohiro.com/reflection.htm
http://d.hatena.ne.jp/token7/
../bin/xpidl -m java nsIScriptableInputStream.idl

http://www.eclipse.org/dltk/install.php
http://wiki.eclipse.org/DLTK_IDE_Guide:Step_3._Towards_an_IDE


http://www13.plala.or.jp/observe/PDE/PDEResourceMarker.html
http://tobysoft.net/wiki/index.php?License%2FMPL
http://atlanto.web.fc2.com/pdt/index.html
http://www.masatom.in/pukiwiki/Eclipse/%A5%D7%A5%E9%A5%B0%A5%A4%A5%F3%B3%AB%C8%AF%A4%CETIPS%BD%B8/%A5%D0%A5%C3%A5%AF%A5%B0%A5%E9%A5%A6%A5%F3%A5%C9%A4%C7%BC%C2%B9%D4%A4%B9%A4%EB/
http://74.125.153.132/search?q=cache:U4rgMoUiLUUJ:codezine.jp/article/detail/353%3Fp%3D2+job.schedule&cd=2&hl=ja&ct=clnk&gl=jp&lr=lang_ja&client=firefox-a
ToolErrorReporter.java
///////////////////////////////////////
XML パースエラー: 定義されていない実体が使用されています。
URL: file:///D:/data/src/PDE/work/stacklink/chrome/content/preference.xul
行番号: 9, 列番号: 1:<prefwindow id="stacklinkpref" xmlns="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul" 
^
XML Parsing Error: undefined entity
Location: file:///D:/data/src/PDE/workrepository/plugins/org.addondev/preview.xul
Line Number 28, Column 9:        <radio value="0" label="&stacklink.pref.label.cropstart;"/>
--------^
//////////////////////////////////////

name = textContent : XML Parsing Error: undefined entity
Location: file:///D:/data/src/PDE/workrepository/plugins/org.addondev/preview.xul
Line Number 1, Column 1512:<?xml version="1.0"?><!DOCTYPE prefwindow SYSTEM "chrome://stacklink/locale/stacklink.dtd" ><?xml-stylesheet href="chrome://global/skin/global.css" type="text/css"?><?xml-stylesheet href="chrome://mozapps/content/preferences/preferences.css"?><?xml-stylesheet href="chrome://stacklink/skin/preference.css" type="text/css"?><prefwindow id="stacklinkpref" xmlns="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul" title="&stacklink.pref;" width="400" bottons="accept,cancel" ondialogaccept="onDialogAccept();"><prefpane id="appearance" label="&stacklink.pref.appearance;" flex="1">    <preferences id="stacklinkAppearancePreferences"><preference id="extensions.stacklink.label" name="extensions.stacklink.label" type="int"/>             <preference id="extensions.stacklink.panel.pos" name="extensions.stacklink.panel.pos" type="int"/>    <preference id="extensions.stacklink.panel.size.maxheight" name="extensions.stacklink.panel.size.maxheight" type="int"/>    <preference id="extensions.stacklink.panel.size.width" name="extensions.stacklink.panel.size.width" type="int"/>    <preference id="extensions.stacklink.css.use" name="extensions.stacklink.css.use" type="bool"/>     <preference id="extensions.stacklink.css.path" name="extensions.stacklink.css.path" type="wstring"/>                       </preferences><groupbox>        <caption label="&stacklink.pref.label;"/>        <radiogroup id="extensions.stacklink.label-radio" orient="horizontal" preference="extensions.stacklink.label">        <radio value="0" label="&stacklink.pref.label.cropstart;"/>        <radio value="1" label="stacklink.pref.label.cropcenter;"/>        <radio value="2" label="stacklink.pref.label.cropend;"/>          <radio value="3" label="&stacklink.pref.label.wrap;"/>        </radiogroup>           </groupbox>        <groupbox orient="vertical"><caption label="&stacklink.pref.panel;"/><hbox align="center"><label value="&stacklink.pref.panel.pos;"/>            <radiogroup orient="horizontal" id="mergewindows" preference="extensions.stacklink.panel.pos">              <radio value="0" id="stacklink.pref.panel.pos.left-radio" label="&stacklink.pref.panel.pos.left;"/>              <radio value="1" id="stacklink.pref.panel.pos.right-radio" label="&stacklink.pref.panel.pos.right;"/>            </radiogroup> </hbox>            <separator class="groove"/>            <label value="&stacklink.pref.panel.size;"/>    <grid>    <columns>    <column/>    <column flex="1"/>    </columns>    <rows>    <row align="center">    <label value="&stacklink.pref.panel.size.maxheight;"/>    <textbox id="extensions.stacklink.panel.size.maxheight-textbox" preference="extensions.stacklink.panel.size.maxheight"/>    </row>    <row align="center">    <label value="&stacklink.pref.panel.size.width;"/>    <textbox id="extensions.stacklink.panel.size.width-textbox" preference="extensions.stacklink.panel.size.width"/>    </row>    </rows>    </grid></groupbox><groupbox orient="vertical"><caption><checkbox id="useCSS" label="stacklink.pref.css;" preference="extensions.stacklink.css.use" onsyncfrompreference="updateCssUse(&apos;useCSS&apos;);"/>      </caption>    <grid>    <columns>    <column/>    <column flex="1"/>    </columns>    <rows>    <row align="center">    <label value="stacklink.pref.css.path;"/>    <textbox id="css-path" group="useCSS" preference="extensions.stacklink.css.path"/>        <button id="css-path-button" group="useCSS" label="Browse..." oncommand="alert(&apos;s&apos;)"/>        </row>    </rows>    </grid>    <hbox align="center">    <spacer flex="1"/>        <button group="useCSS" label="stacklink.pref.css.apply;" oncommand="updateCss(document.getElementById(&apos;css-path&apos;));"/>    </hbox> </groupbox></prefpane>        <script type="application/x-javascript" src="chrome://stacklink/content/preference.js"/></prefwindow>
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------^


///////////////
content stacklink file:///D:/data/src/PDE/eclipse/work/stacklink/chrome/content/  contentaccessible=yes 
skin	stacklink	classic/1.0	 file:///D:/data/src/PDE/eclipse/work/stacklink/skin/classic/

locale	stacklink	ja-JP		 file:///D:/data/src/PDE/eclipse/work/stacklink/locale/ja-JP/
locale	stacklink	en-US		 file:///D:/data/src/PDE/eclipse/work/stacklink/locale/en-US/



//////////////
Mozilla XULRunner 1.9.1.4

Usage: xulrunner [OPTIONS]
       xulrunner APP-FILE [APP-OPTIONS...]

OPTIONS
      --app                  specify APP-FILE (optional)
  -h, --help                 show this message
  -v, --version              show version
  --gre-version              print the GRE version string on stdout
  --register-global          register this GRE in the machine registry
  --register-user            register this GRE in the user registry
  --unregister-global        unregister this GRE formerly registered with
                             --register-global
  --unregister-user          unregister this GRE formely registered with
                             --register-user
  --find-gre <version>       Find a GRE with version <version> and print
                             the path on stdout
  --install-app <application> [<destination> [<directoryname>]]
                             Install a XUL application.

APP-FILE
  Application initialization file.

APP-OPTIONS
  Application specific opti????@?@単?単?
////////////
file.getLocation().removeLastSegments(1);
fBasePath	Path  (id=6886)	
D:/data/src/PDE/workrepository/plugins/AddonDev/test0

file.getFullPath().removeLastSegments(1);
/test0

http://d.hatena.ne.jp/t-katochin/20081217/1229498352
http://74.125.153.132/search?q=cache:Zuh2eRuMsS4J:www.eisbahn.jp/yoichiro/2007/06/web_1.html+%22browser.setText%22+swt&cd=4&hl=ja&ct=clnk&gl=jp&lr=lang_ja&client=firefox-a
http://cms.xulbooster.org/index.php?option=com_frontpage&Itemid=1
http://www.open-force.info/index.php/blog/show/l/77

//////////////////////////////////////////////////////



function convertToXULElement(str){

var XUL_NS = "http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul";
	str = str.toXMLString? str.toXMLString() : str;
	alert("convertToXULElement0 = " + XUL_NS);
	var xul = (
		'<box xmlns="'+XUL_NS+'" >'+
			str + 
		'</box>').replace(/^  +/gm, '').replace(/\n/g, '');
	alert("convertToXULElement1 = ");
	var parser = new DOMParser();
	var elms = parser.parseFromString(xul, 'application/xml').documentElement.childNodes;
	alert("convertToXULElement2 = ");
	
	var range = document.createRange();
	//var result = currentDocument().createDocumentFragment();
	var result = range.createDocumentFragment();
	
	alert("convertToXULElement3 = ");
	for(var i=0 ; i<elms.length ; i++)
		result.appendChild(elms[i]);
		
	range.detach();
		alert("convertToXULElement = " + result);
		
	return result;
};

function ww()
{
//document.documentElement.appendChild(convertToXULElement(<>
document.getElementById("content").appendChild(convertToXULElement(<>
  <button label="HELLO"/>
  <button label="WORLD"/>
  <button label="!!!"/>
</>));
/*
var range = document.createRange();
range.selectNodeContents(document.getElementById('content'));
range.collapse(false);
range.extractContents();
//range.setStartAfter(document.getElementById("page-report-button"));
range.insertNode(range.createContextualFragment(<![CDATA[
<button label="HELLO"/>
]]>.toString().replace(/^[\s\t]*|[\s\t]*$/g, '').replace(/>[\s\t]+</g, '><')));
range.detach();
*/

};
/////////////////////
<?xml version="1.0"?>
<?xml-stylesheet href="chrome://global/skin/" type="text/css"?>
<window id="xuledit" xmlns="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul">
<script type="application/x-javascript" src="test.js"/>

	<script type="text/javascript">
	var xwin;
	var gddd;
	function preview(text) {
	
	ww();
	/*
		try{
	    	xwin = document.getElementById("content");
			var dataURI = "data:application/vnd.mozilla.xul+xml," + text;
			gddd = text;
	    	xwin.setAttribute("src",dataURI);
	    	//xwin.document.location = dataURI;
	    }catch(exc){
	    	alert(res);
	    }
	*/
	};

	function rep()
	{
		return "repalce";
	};

	function getDoc() {
		//alert("getDoc");
		var res = "";
		var parser = new DOMParser();
		var doc = parser.parseFromString(gddd, "text/xml");
		//alert(doc);
 		var errorNS = "http://www.mozilla.org/newlayout/xml/parsererror.xml";
 		//alert(doc.getElementsByTagName('parsererror'));
  		//alert(doc.nodeName);
  
  			
  			var obj = doc.getElementsByTagNameNS(errorNS, 'parsererror')[0];
  			/*
			for(var name in obj)
			{
				try{
					res += "name = " + name +" : " + obj[name] + "\n"; 
				}catch(exc){
					res += "name = " + name +" ERROR" + "\n"; 
				}
			}
			alert( res );
		    */
		    //alert(doc.getElementsByTagNameNS(errorNS, 'parsererror'));
  		doc = obj;
  		
 		if((doc.nodeName == 'parsererror') )
 		{
 			if((doc.namespaceURI == errorNS))
 			{
         		var sourceText = doc.getElementsByTagNameNS(errorNS, 'sourcetext')[0];
         		//alert(sourceText);
         		/*
         					for(var name in sourceText)
			{
				try{
					res += "name = " + name +" : " + sourceText[name] + "\n"; 
				}catch(exc){
					res += "name = " + name +" ERROR" + "\n"; 
				}
			}
			alert( res );
			*/
         		if(!sourceText){
                 	sourceText = sourceText.firstChild.data;
                 	alert("!sourceText = " + sourceText);
         		}
         	}
         }
 			//throw new Error("Error parsing text " + nativeDoc.documentElement.firstChild.data + " \n"  + sourceText);
 	} ;
	//var ww = window.open('about:blank', 'xulwin', 'chrome,all,resizable=yes,width=400,height=400');
	//alert(ww);
	//alert( xwin.childNodes[1].nodeName);

	/*
		var paragraphCount = document.evaluate( '//parsererror', document, null, XPathResult.ANY_TYPE, null );
		try {
			var obj = paragraphCount;
			for(var name in obj)
			{
				try{
					res += "name = " + name +" : " + obj[name] + "\n"; 
				}catch(exc){
					res += "name = " + name +" ERROR" + "\n"; 
				}
			}
				alert( res );
		    }
		
		//alert(paragraphCount.iterateNext());
	  		var thisNode = paragraphCount.iterateNext();
	  		while (thisNode) 
	  		{
	    		alert( thisNode.textContent );
	    		thisNode = iterator.iterateNext();
	  		}
	 	}catch(exc){
	   		alert(exc);
	 	}
	 	*/
	/*
	//alert( paragraphCount );
	var res = "";
	var obj = paragraphCount;
		for(var name in obj)
		{
			try{
				res += "name = " + name +" : " + obj[name] + "\n"; 
			}catch(exc){
				res += "name = " + name +" ERROR" + "\n"; 
			}
		}
		alert( res );
		    }catch(exc){
	    	alert(exc);
	    }
	    */
	//var res = "";
	
	//var obj = document.getElementById("content");
	//alert(obj.children.toString());
	//var obj = document.documentElement.firstElementChild;
	
	//var w = window._content;
 	//var d = w.document;
 	//alert(document.getElementById("content").attributes);
	//alert(document.documentElement.body);

	/*
	var obj = document.getElementById("content").attributes[2];

		for(var name in obj)
		{
			try{
				res += "name = " + name +" : " + obj[name] + "\n"; 
			}catch(exc){
				res += "name = " + name +" ERROR" + "\n"; 
			}
		}

		alert(res);
		*/
		//alert(document.getElementById("content").innerText);
		//alert(document.getElementById("content").ownerDocument.innerHTML);//getAttribute("src"));
		//var doc = document.getElementById("content").contentDocument;
		//alert(document.getElementsByTagName("content").innerHTML);
		//alert(doc.body.innerHTML);
		//alert(document.innerHTML);
	//}

	</script>

	<iframe id="content" src="about:blank" flex="1"/>
</window>

//to debugger
cmd=load&filename=[filename]
cmd=resume
cmd=stepover
cmd=stepinto
cmd=stepout
cmd=setbreakpoint&filename=[filename]&line=[line]
cmd=getstackframes
cmd=getvalues&stackframedepth=depth&name=[name]
cmd=getexp&exp=[exp]




//form debugger
cmd=suspend
data=
<xml>
<stackframe depth="[depth]" filename="[filename]" functionname="[functionname]" line="[line]"/>
.
.
.
</xml>


cmd=exp
data=
<xml>
<var name="[name]" type="[type]" value="[value]" hasChildren=[true/false]"/>
</xml>

cmd=values
data=
<xml>
<var name="[name]" type="[type]" value="[value]" hasChildren="[true/false]"/>
.
.
.
</xml>

cmd=error
data=
<xml>
<error filename="[filename]" line="[line]" msg="[errorMessage]"/>
.
.
.
</xml>

cmd=log
data=
<xml>
<log msg="[errorMessage]"/>
.
.
.
</xml>
////////////////////////////////////////////////////
/* -*- Mode: C; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
/*
 * The contents of this file are subject to the Mozilla Public
 * License Version 1.1 (the "License"); you may not use this file
 * except in compliance with the License. You may obtain a copy of
 * the License at http://www.mozilla.org/MPL/
 *
 * Software distributed under the License is distributed on an "AS
 * IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
 * implied. See the License for the specific language governing
 * rights and limitations under the License.
 *
 * The Original Code is mozilla.org code.
 *
 * The Initial Developer of the Original Code is Sun Microsystems, 
 * Inc. Portions created by Sun are
 * Copyright (C) 1999 Sun Microsystems, Inc. All
 * Rights Reserved.
 *
 * Contributor(s): 
 *    Michael Allen (michael.allen@sun.com)
 *    Frank Mitchell (frank.mitchell@sun.com)
 */

/*
 * Generate Java interfaces from XPIDL.
 */

#include "xpidl.h"
#include <ctype.h>
#include <glib.h>


struct java_priv_data {
    GHashTable *typedefTable;
};

#define TYPEDEFS(state)     (((struct java_priv_data *)state->priv)->typedefTable)

//add
char ifname[256];

static gboolean
write_classname_iid_define(FILE *file, const char *className)
{
    const char *iidName;
    if (className[0] == 'n' && className[1] == 's') {
        /* backcompat naming styles */
        fputs("NS_", file);
        iidName = className + 2;
    } else {
        iidName = className;
    }

    while (*iidName) {
        fputc(toupper(*iidName++), file);
    }

    fputs("_IID", file);
    return TRUE;
}

static gboolean
java_prolog(TreeState *state)
{
    state->priv = calloc(1, sizeof(struct java_priv_data));
    if (!state->priv)
        return FALSE;
    TYPEDEFS(state) = 0;
    TYPEDEFS(state) = g_hash_table_new(g_str_hash, g_str_equal);
    if (!TYPEDEFS(state)) {
        /* XXX report error */
        free(state->priv);
        return FALSE;
    }
    
    /*
     * First pass
     */
    
    fputs("/*\n * ************* DO NOT EDIT THIS FILE ***********\n",
          state->file);
   
    fprintf(state->file, 
            " *\n * This file was automatically generated from %s.idl.\n", 
            state->basename);
    
    fputs(" */\n\n", state->file);
	
    return TRUE;
}

static gboolean 
java_epilog(TreeState *state)
{
    /* points to other elements of the tree, so just destroy the table */
    g_hash_table_destroy(TYPEDEFS(state));
    free(state->priv);
    state->priv = NULL;
    
    /*
     * Last pass
     */
    
    fprintf(state->file, "\n/*\n * end\n */\n");

    return TRUE;
}

static gboolean
forward_declaration(TreeState *state) 
{
    /*
     * Java doesn't need forward declarations unless the declared 
     * class resides in a different package.
     */
#if 0
    IDL_tree iface = state->tree;
    const char *className = IDL_IDENT(IDL_FORWARD_DCL(iface).ident).str;
    const char *pkgName = "org.mozilla.xpcom";
    if (!className)
        return FALSE;
    /* XXX: Get package name and compare */
    fprintf(state->file, "import %s.%s;\n", pkgName, className);
#endif
    return TRUE;
}


static gboolean
interface_declaration(TreeState *state) 
{
    IDL_tree interface = state->tree;
    IDL_tree iterator = NULL;
    char *interface_name = IDL_IDENT(IDL_INTERFACE(interface).ident).str;
    const char *iid = NULL;

    if (!verify_interface_declaration(interface))
        return FALSE;

	strcpy(ifname, interface_name);

    /*
     * Write out JavaDoc comment
     */

    fprintf(state->file, "\n/**\n * Interface %s\n", interface_name);

#ifndef LIBIDL_MAJOR_VERSION
    iid = IDL_tree_property_get(interface, "uuid");
#else
    iid = IDL_tree_property_get(IDL_INTERFACE(interface).ident, "uuid");
#endif

    if (iid != NULL) {
        fprintf(state->file, " *\n * IID: 0x%s\n */\n\n", iid);
    } else {
        fputs(" */\n\n", state->file);
    }


    /*
     * Write "public interface <foo>"
     */

    fprintf(state->file, "public interface %s ", interface_name);

    /*
     * Check for inheritence, and iterator over the inherited names,
     * if any.
     */

    if ((iterator = IDL_INTERFACE(interface).inheritance_spec)) {
        fputs("extends ", state->file);

        do {

            fprintf(state->file, "%s", 
                    IDL_IDENT(IDL_LIST(iterator).data).str);
	    
            if (IDL_LIST(iterator).next) {
                fputs(", ", state->file);
            }
        } while ((iterator = IDL_LIST(iterator).next));

    }

    fputs("\n{\n", state->file);
    
    if (iid) {
        /*
         * Write interface constants for IID
         */

        fputs("    public static final String ", state->file);

        /* XXX s.b just "IID" ? */
        if (!write_classname_iid_define(state->file, interface_name)) {
            return FALSE;
        }

        fprintf(state->file, "_STRING =\n        \"%s\";\n\n", iid);

        fputs("    public static final nsID ", state->file);

        /* XXX s.b just "IID" ? */
        if (!write_classname_iid_define(state->file, interface_name)) {
            return FALSE;
        }

        fprintf(state->file, " =\n        new nsID(\"%s\");\n\n", iid);
    }

    /*
     * Advance the state of the tree, go on to process more
     */
    
    state->tree = IDL_INTERFACE(interface).body;

    if (state->tree && !xpidl_process_node(state)) {
        return FALSE;
    }


    fputs("\n}\n", state->file);

    return TRUE;
}

static gboolean
process_list(TreeState *state)
{
    IDL_tree iter;
    for (iter = state->tree; iter; iter = IDL_LIST(iter).next) {
        state->tree = IDL_LIST(iter).data;
        if (!xpidl_process_node(state))
            return FALSE;
    }
    return TRUE;
}

static gboolean 
xpcom_to_java_type (TreeState *state) 
{
    if (!state->tree) {
        fputs("Object", state->file);
        return TRUE;
    }

    switch(IDL_NODE_TYPE(state->tree)) {

    case IDLN_TYPE_INTEGER: {

        switch(IDL_TYPE_INTEGER(state->tree).f_type) {

        case IDL_INTEGER_TYPE_SHORT:
            fputs("short", state->file);
            break;

        case IDL_INTEGER_TYPE_LONG:
            fputs("int", state->file);
            break;

        case IDL_INTEGER_TYPE_LONGLONG:
            fputs("long", state->file);
            break;
	    
        default:
            g_error("   Unknown integer type: %d\n",
                    IDL_TYPE_INTEGER(state->tree).f_type);
            return FALSE;

        }

        break;
    }

    case IDLN_TYPE_CHAR:
    case IDLN_TYPE_WIDE_CHAR:
        fputs("char", state->file);
        break;

    case IDLN_TYPE_WIDE_STRING:
    case IDLN_TYPE_STRING:
        fputs("String", state->file);
        break;

    case IDLN_TYPE_BOOLEAN:
        fputs("boolean", state->file);
        break;

    case IDLN_TYPE_OCTET:
        fputs("byte", state->file);
        break;

    case IDLN_TYPE_FLOAT:
        switch(IDL_TYPE_FLOAT(state->tree).f_type) {

        case IDL_FLOAT_TYPE_FLOAT:
            fputs("float", state->file);
            break;

        case IDL_FLOAT_TYPE_DOUBLE:
            fputs("double", state->file);
            break;
	    
        default:
            g_error("    Unknown floating point typ: %d\n",
                    IDL_NODE_TYPE(state->tree));
            break;
        }
        break;


    case IDLN_IDENT:
        if (IDL_NODE_UP(state->tree) &&
            IDL_NODE_TYPE(IDL_NODE_UP(state->tree)) == IDLN_NATIVE) {
            const char *user_type = IDL_NATIVE(IDL_NODE_UP(state->tree)).user_type;
            if (strcmp(user_type, "void") == 0) {
                fputs("Object", state->file);
            }
            else if (strcmp(user_type, "nsID") == 0 ||
                     strcmp(user_type, "nsIID") == 0 ||
                     strcmp(user_type, "nsCID") == 0) {
                /* XXX: s.b test for "iid" attribute */
                /* XXX: special class for nsIDs */
                fputs("nsID", state->file);
            }
            else {
                /* XXX: special class for opaque types */
                fputs("OpaqueValue", state->file);
            }
        } else {
            const char *ident_str = IDL_IDENT(state->tree).str;

            /* XXX: big kludge; s.b. way to match to typedefs */
            if (strcmp(ident_str, "PRInt8") == 0 ||
                strcmp(ident_str, "PRUint8") == 0) {
                fputs("byte", state->file);
            }
            else if (strcmp(ident_str, "PRInt16") == 0 ||
                     strcmp(ident_str, "PRUint16") == 0) {
                fputs("short", state->file);
            }
            else if (strcmp(ident_str, "PRInt32") == 0 ||
                     strcmp(ident_str, "PRUint32") == 0) {
                fputs("int", state->file);
            }
            else if (strcmp(ident_str, "PRInt64") == 0 ||
                     strcmp(ident_str, "PRUint64") == 0) {
                fputs("long", state->file);
            }
            else if (strcmp(ident_str, "PRBool") == 0) {
                fputs("boolean", state->file);
            }
            else if (strcmp(ident_str, "nsrefcnt") == 0) {
                fputs("int", state->file);
            }
            else {
                IDL_tree real_type = 
                    g_hash_table_lookup(TYPEDEFS(state), ident_str);

                if (real_type) {
                    IDL_tree orig_tree = state->tree;

                    state->tree = real_type;
                    xpcom_to_java_type(state);

                    state->tree = orig_tree;
                }
                else {
                    fputs(ident_str, state->file);

					//add1
					printf("MM %s", ident_str);
                }
            }
        }

        break;

    case IDLN_TYPE_ENUM:
    case IDLN_TYPE_OBJECT:
    default:
        g_error("    Unknown type: %d\n",
                IDL_TYPE_FLOAT(state->tree).f_type);
        break;
    }

    return TRUE;

}

static gboolean
xpcom_to_java_param(TreeState *state) 
{
    IDL_tree param = state->tree;
    state->tree = IDL_PARAM_DCL(param).param_type_spec;

    /*
     * Put in type of parameter
     */

    if (!xpcom_to_java_type(state)) {
        return FALSE;
    }

    /*
     * If the parameter is out or inout, make it a Java array of the
     * appropriate type
     */

    if (IDL_PARAM_DCL(param).attr != IDL_PARAM_IN) {
        fputs("[]", state->file);
    }

    /*
     * Put in name of parameter 
     */

    fputc(' ', state->file);

    fputs(IDL_IDENT(IDL_PARAM_DCL(param).simple_declarator).str, state->file);

    return TRUE;
}


static gboolean
type_declaration(TreeState *state) 
{
    /*
     * Unlike C, Java has no type declaration directive.
     * Instead, we record the mapping, and look up the actual type
     * when needed.
     */
    IDL_tree type = IDL_TYPE_DCL(state->tree).type_spec;
    IDL_tree dcls = IDL_TYPE_DCL(state->tree).dcls;

    /* XXX: check for illegal types */

    g_hash_table_insert(TYPEDEFS(state),
                        IDL_IDENT(IDL_LIST(dcls).data).str,
                        type);

    return TRUE;
}

static gboolean
method_declaration(TreeState *state) 
{
    /* IDL_tree method_tree = state->tree; */
    struct _IDL_OP_DCL *method = &IDL_OP_DCL(state->tree);
    gboolean method_notxpcom = 
        (IDL_tree_property_get(method->ident, "notxpcom") != NULL);
    gboolean method_noscript = 
        (IDL_tree_property_get(method->ident, "noscript") != NULL);
    IDL_tree iterator = NULL;
    IDL_tree retval_param = NULL;
    const char *method_name = IDL_IDENT(method->ident).str;

	//add
	//IDL_tree interface = state->tree;
    //char *interface_name = IDL_IDENT(IDL_INTERFACE(interface).ident).str;

    if (!verify_method_declaration(state->tree))
        return FALSE;

    fputc('\n', state->file);
    xpidl_write_comment(state, 4);

    /*
     * Write beginning of method declaration
     */
    fputs("    ", state->file);
    if (!method_noscript) {
        /* Nonscriptable methods become package-protected */
        fputs("public ", state->file);
    }

    /*
     * Write return type
     * Unlike C++ headers, Java interfaces return the declared 
     * return value; an exception indicates XPCOM method failure.
     */
    if (method_notxpcom || method->op_type_spec) {
        state->tree = method->op_type_spec;
        if (!xpcom_to_java_type(state)) {
            return FALSE;
        }
    } else {
        /* Check for retval attribute */
        for (iterator = method->parameter_dcls; iterator != NULL; 
             iterator = IDL_LIST(iterator).next) {

            IDL_tree original_tree = state->tree;

            state->tree = IDL_LIST(iterator).data;

            if (IDL_tree_property_get(IDL_PARAM_DCL(state->tree).simple_declarator, 
                                      "retval")) {
                retval_param = iterator;

                state->tree = IDL_PARAM_DCL(state->tree).param_type_spec;

                /*
                 * Put in type of parameter
                 */

                if (!xpcom_to_java_type(state)) {
                    return FALSE;
                }
            }

            state->tree = original_tree;
        }

        if (retval_param == NULL) {
            fputs("void", state->file);
        }
    }
 
    /*
     * Write method name
     */
    fprintf(state->file, " %c%s(", tolower(method_name[0]), method_name + 1);

	//add
	printf("%s %s %c%s %s ", ifname, "FUNCTION_PROP", tolower(method_name[0]), method_name + 1, method_name);

    /*
     * Write parameters
     */
    for (iterator = method->parameter_dcls; iterator != NULL; 
         iterator = IDL_LIST(iterator).next) {

        /* Skip "retval" */
        if (iterator == retval_param) {
            continue;
        }

        if (iterator != method->parameter_dcls) {
            fputs(", ", state->file);
        }
        
        state->tree = IDL_LIST(iterator).data;

        if (!xpcom_to_java_param(state)) {
            return FALSE;
        }
    }

    fputs(")", state->file);

    if (method->raises_expr) {
        IDL_tree iter = method->raises_expr;
        IDL_tree dataNode = IDL_LIST(iter).data;

        fputs(" throws ", state->file);
        fputs(IDL_IDENT(dataNode).str, state->file);
        iter = IDL_LIST(iter).next;

        while (iter) {
            dataNode = IDL_LIST(iter).data;
            fprintf(state->file, ", %s", IDL_IDENT(dataNode).str);
            iter = IDL_LIST(iter).next;
        }
    }

    fputs(";\n", state->file);

	//add1
	printf("\n");

    return TRUE;
    
}


static gboolean
constant_declaration(TreeState *state)
{
    struct _IDL_CONST_DCL *declaration = &IDL_CONST_DCL(state->tree);
    const char *name = IDL_IDENT(declaration->ident).str;
    IDL_tree real_type;

    if (!verify_const_declaration(state->tree))
        return FALSE;

    /* Could be a typedef; try to map it to the real type. */
    real_type = find_underlying_type(declaration->const_type);
    real_type = real_type ? real_type : declaration->const_type;

    fputc('\n', state->file);
    xpidl_write_comment(state, 4);

    fprintf(state->file, "    public static final %s %s = %d;\n",
            (IDL_TYPE_INTEGER(real_type).f_type == IDL_INTEGER_TYPE_LONG
             ? "long" : "short"),
            name, (int) IDL_INTEGER(declaration->const_exp).value);

    return TRUE;

}

#define ATTR_IDENT(tree) (IDL_IDENT(IDL_LIST(IDL_ATTR_DCL((tree)).simple_declarations).data))
#define ATTR_PROPS(tree) (IDL_LIST(IDL_ATTR_DCL((tree)).simple_declarations).data)
#define ATTR_TYPE_DECL(tree) (IDL_ATTR_DCL((tree)).param_type_spec)


static gboolean
attribute_declaration(TreeState *state)
{
    gboolean read_only = IDL_ATTR_DCL(state->tree).f_readonly;
    char *attribute_name = ATTR_IDENT(state->tree).str;

    gboolean method_noscript = 
        (IDL_tree_property_get(ATTR_PROPS(state->tree), "noscript") != NULL);

	//add
	//IDL_tree interface = state->tree;
    //char *interface_name = IDL_IDENT(IDL_INTERFACE(interface).ident).str;

#if 0
    /*
     * Disabled here because I can't verify this check against possible
     * users of the java xpidl backend.
     */
    if (!verify_attribute_declaration(state->tree))
        return FALSE;
#endif

    /* Comment */
    fputc('\n', state->file);
    xpidl_write_comment(state, 4);

    state->tree = ATTR_TYPE_DECL(state->tree);

    /*
     * Write access permission ("public" unless nonscriptable)
     */
    fputs("    ", state->file);
    if (!method_noscript) {
        fputs("public ", state->file);
    }

    /*
     * Write the proper Java return value for the get operation
     */
    if (!xpcom_to_java_type(state)) {
        return FALSE;
    }
    
    /*
     * Write the name of the accessor ("get") method.
     */
    fprintf(state->file, " get%c%s();\n",
            toupper(attribute_name[0]), attribute_name + 1);
	
	//add
	printf("%s %s get%c%s %s\n", ifname, "VALUE_PROP", toupper(attribute_name[0]), attribute_name+1, attribute_name);

    if (!read_only) {
        /* Nonscriptable methods become package-protected */
        fputs("    ", state->file);
        if (!method_noscript) {
            fputs("public ", state->file);
        }

        /*
         * Write attribute access method name and return type
         */
        fprintf(state->file, "void set%c%s(",
                toupper(attribute_name[0]), 
                attribute_name+1);
        
        /*
         * Write the proper Java type for the set operation
         */
        if (!xpcom_to_java_type(state)) {
            return FALSE;
        }

        /*
         * Write the name of the formal parameter.
         */
        fputs(" value);\n", state->file);

		//add
		printf("%s %s set%c%s %s\n", ifname, "VALUE_PROP", toupper(attribute_name[0]), attribute_name+1, attribute_name);
    }
	
    return TRUE;
}


static gboolean
enum_declaration(TreeState *state)
{
    XPIDL_WARNING((state->tree, IDL_WARNING1,
                   "enums not supported, enum \'%s\' ignored",
                   IDL_IDENT(IDL_TYPE_ENUM(state->tree).ident).str));
    return TRUE;
}

backend *
xpidl_java_dispatch(void)
{
    static backend result;
    static nodeHandler table[IDLN_LAST];
    static gboolean initialized = FALSE;

    result.emit_prolog = java_prolog;
    result.emit_epilog = java_epilog;

    if (!initialized) {
        table[IDLN_INTERFACE] = interface_declaration;
        table[IDLN_LIST] = process_list;

        table[IDLN_OP_DCL] = method_declaration;
        table[IDLN_ATTR_DCL] = attribute_declaration;
        table[IDLN_CONST_DCL] = constant_declaration;

        table[IDLN_TYPE_DCL] = type_declaration;
        table[IDLN_FORWARD_DCL] = forward_declaration;

        table[IDLN_TYPE_ENUM] = enum_declaration;

        initialized = TRUE;
    }

    result.dispatch_table = table;
    return &result;
}
